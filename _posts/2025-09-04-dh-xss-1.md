---
layout: post
title: "[DH] xss-1"
category: Write-Up
tag:
- dreamhack
- web
date: 2025-09-04 17:02 +0900
---
### INFO
![chall]
_Fig 1. challenge_

취약한 웹 페이지 주소와 소스코드가 주어진다.

### RECON

#### 동적 분석
![recon_1]
_Fig 2. recon 1_

Fig 2와 같이 웹 페이지에 접속하면, 바로 3개의 페이지를 확인할 수 있다.

각각의 페이지는 다음과 같은 의미를 가진다.
    
(1) `vuln?param=` 뒤에 오는 코드를 실행시킬 수 있음을 보여주는 페이지 <br>
(2) 변수 `memo`에 값을 추가하고 저장된 값을 출력하는 페이지<br>
(3) 서버에서 실행시킬 코드를 입력할 수 있는 페이지<br>

#### 정적 분석

그렇다면 플래그는 어디에 있고, 어떻게 획득할 수 있을까?

![recon_2]
_Fig 3. recon_2_

코드를 통해 분석한 동작은 Fig 3과 같다. (잘못된 부분이 있을 수 있습니다. 번거로우시겠지만, 아직 댓글창이 없어서 이메일로 잘못된 부분을 알려주신다면 정말 감사하겠습니다..)

정적 분석을 통해, 서버가 Flask 웹 서버와 Selenium을 사용한 봇을 운용하는 것을 확인했다.

봇은 `/flag?param=PAYLOAD`에 의해 트리거되며, 
`driver.get(http://127.0.0.1:8000/vuln?param={urllib.parse.quote(PAYLOAD)})`을 동작한다.

바로 이 부분이 취약한 부분이라고 판단하고 문제 풀이에 들어갔다.

### SOLVE

![solve_1]
_Fig 4. solve 1_

플래그 획득 과정에서 가장 중요한 부분은 봇이 가지고 있는 쿠키를 어떻게 웹 서버에게 넘겨줄 것인가다.

이를 실현시키기 위해서 location.href를 사용해서 "`/memo?memo="+document.cookie` 경로로 값을 전송해준다. 이는 0.0.0.0:8000에 바인딩된 웹 서버가 받아서 memo에 쿠키값을 써내려갈 페이로드이다.

### 의문점

#### Q1. 왜 SERVERIP:SERVERPORT/memo?memo는 동작하지 않는가?

A1. 함수 `read_url()`의 `cookie.update({"domain": "127.0.0.1"})`에서 보이는 쿠키값은 127.0.0.1 오리진에서만 건들일 수 있다고 설정해뒀기 때문입니다.

#### Q2. 어떻게 127.0.0.1에서 /vuln에 접근할 수 있는거지?

A2. 웹 서버가 0.0.0.0:8000에 바인딩되었기 때문에, 서버 내부에서 작동하는 Selenium은 접근이 가능합니다.

#### Q3. 어려워요. 간단하게 정리해주세요.

간단하게.. `/vuln` 경로에 임의의 코드를 실행할 수 있는 취약점이 있었어요. 하지만 이는 로컬 환경에서 동작하는 것이라서 취약점은 아니었어요.

하지만 `/flag` 경로에서는 서버 내부에 봇(크롬창)을 띄워서 임의의 코드를 동작시킬 수 있었어요. 이는 서버 내부에서 동작하는 것이라 많이 위험했죠.

결국 서버 내부에 안전하게(?) 있던 플래그를 메모해서 공격자는 얻을 수 있었어요. 이는 임의의 페이로드를 서버에 삽입하여 동작시킬 수 있는 reflected XSS에 대한 문제였어요.

[chall]: /assets/DreamHack/xss-1/문제.png
[recon_1]: /assets/DreamHack/xss-1/recon_1.png
[recon_2]: /assets/DreamHack/xss-1/recon_2.png
[solve_1]: /assets/DreamHack/xss-1/solve_1.png