---
layout: post
title: "[DH] dungeon-in-1983"
category: Write-Up
tag:
- dreamhack
- reversing
date: 2025-09-09 16:22 +0900
---

### INFO
![chall]
_Fig 1. challenge_

![files]
_Fig 2. files_

주어진 파일과 문제를 보았을 때, 실제 플래그를 가지고 있는 프로그램은 서버에서 동작하고 있음을 알 수 있다.
### RECON
`strings prob` 를 통해, 프로그램 내부에서 'Kraken'이나 'Each monster requires certain series of key combinations to be defeated, so be careful!' 같은 게임에서 나올 법한 문자열들을 확인 할 수 있다.

아마 각 스테이지마다 올바른 입력값을 넣어야 플래그를 획득 할 수 있을 것 같다.

#### 동적 분석
``` 출력
Welcome to the Dungeon!
You have only two buttons: A and B.
Each monster requires certain series of key combinations to be defeated, so be careful!
[STAGE  1]: Basilisk
[INFO] HP: 56870, STR:   132, AGI:    56, VIT:   239, INT:    20, END:   109, DEX:    24
Cast your spell!: ABBBB
You were defeated. Retreat!
```

추가로 5초 정도의 시간 제한이 존재하는 것을 확인했다. (strace나 ltrace에서 비교하는 것이 보이지 않는다. 왜 그런지는 추가로 조사해보겠다.)

### 정적 분석
그렇다면 실제 어떤 입력을 요구할까?

`[INFO] ...` 문장을 출력하는 함수을 보면 다음과 같다.

``` c
void set_info(ulong buf)
{
  printf("[INFO] HP: %5hu, STR: %5hhu, AGI: %5hhu, VIT: %5hhu, INT: %5hhu, END: %5hhu, DEX: %5hhu\n "
         ,buf >> 0x30,buf & 0xff,buf >> 0x8 & 0xff,buf >> 0x10 & 0xff,buf >> 0x18 & 0xff,
         buf >> 0x20 & 0xff,buf >> 0x28 & 0xff);
  return;
}
```

랜덤으로 설정된 정답(입력값)이 파싱되어서 출력됨을 의미한다. 각각의 변수들은 정답의 해당 부분을 차지한다.

![parsing_cheetsheet]
_Fig 3. parsing sheet_

이렇게 정답의 binary 배열을 알 수 있다. 그렇다면 A와 B로 0, 1을 처리하는 로직을 찾아보자.

함수 `FUN_00101407`가 해당 역할을 수행하는 함수이다.

내부적으로 입력값에 대한 검증과 계산을 수행하며, 외부적으로 정답에 대한 결과를 출력하는 함수이다.

수행하는 검증은 다음과 같다.
    1. 맨 첫 글자는 `A`이다.
    2. `A`는 연속해서 올 수 없다.
    3. `A`와 `B` 이외의 글자는 올 수 없다.

수행하는 계산은 다음과 같다.
    `A` -> 1 더하기 연산
    `B` -> 1비트 쉬프트 연산

### SOLVE
![sol_1]
_Fig 4. 시각화(?)_

풀이과정
    (0)	[INFO] HP: ...
    (1)	정답 비트값 추출
    (2)	A/B문자열 연산

poc는 pwntools와 re를 사용하여 작성했다.

### POC
```
from pwn import *
import re

pattern = re.compile(
    r"HP:\s*(\d+),\s*STR:\s*(\d+),\s*AGI:\s*(\d+),\s*VIT:\s*(\d+),\s*INT:\s*(\d+),\s*END:\s*(\d+),\s*DEX:\s*(\d+)"
)

def pack_stats(hp, str_, agi, vit, int_, end, dex):
    buf  = (hp  & 0xFFFF) << 48
    buf |= (dex & 0xFF)   << 40
    buf |= (end & 0xFF)   << 32
    buf |= (int_ & 0xFF)  << 24
    buf |= (vit & 0xFF)   << 16
    buf |= (agi & 0xFF)   << 8
    buf |= (str_ & 0xFF)
    return buf

def buf_to_ab(buf: int) -> str:
    bits = bin(buf)[2:]  # buf+1
    
    seq = "A"

    for b in bits[1:]:
        seq += "B"      # 시프트 한 칸
        if b == "1":
            seq += "A"  # 1로 세팅

    return seq

if __name__ == "__main__":
    HOST = 
    PORT = 

    conn = remote(HOST, PORT)

    idx = 0
    while idx < 10:
        conn.recvuntil(b'[INFO] ')

        line = conn.recvline().decode() # [INFO] 뒤의 문자열 긁어오기
        match = pattern.search(line)
        if match:
            hp, str_, agi, vit, int_, end, dex = map(int, match.groups())
            buf = buf_to_ab(pack_stats(hp, str_, agi, vit, int_, end, dex))
        conn.recvuntil(b"Cast your spell!:")

        conn.sendline(buf.encode())
        idx += 1

    data = conn.recvall(timeout=2)  # 서버가 보내는 거 다 읽기
    print(data.decode())
```

[chall]: /assets/DreamHack/dungeon-in-1983/chall.png
[files]: /assets/DreamHack/dungeon-in-1983/files.png
[parsing_cheetsheet]: /assets/DreamHack/dungeon-in-1983/parsing_cheetsheet.png
[sol_1]: /assets/DreamHack/dungeon-in-1983/sol_1.png